<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parser Turni ACTV v1.0</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', sans-serif; padding: 20px; background: #f0f2f5; }
        .container { max-width: 850px; margin: auto; background: white; padding: 30px; border-radius: 15px; box-shadow: 0 4px 20px rgba(0,0,0,0.1); }
        h1 { color: #d32f2f; text-align: center; border-bottom: 2px solid #eee; padding-bottom: 10px; }
        .upload-section { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0; }
        .box { border: 2px dashed #ccc; padding: 20px; border-radius: 10px; text-align: center; background: #fafafa; }
        button { background: #d32f2f; color: white; border: none; padding: 15px; border-radius: 8px; cursor: pointer; width: 100%; font-size: 1.1rem; font-weight: bold; }
        #log { margin-top: 20px; padding: 15px; background: #1e1e1e; color: #00ff00; border-radius: 8px; font-family: 'Consolas', monospace; font-size: 0.85rem; height: 350px; overflow-y: auto; white-space: pre-wrap; }
        .progress { height: 10px; background: #eee; border-radius: 5px; margin-bottom: 10px; overflow: hidden; display: none; }
        #bar { height: 100%; background: #f44336; width: 0%; transition: 0.1s; }
    </style>
</head>
<body>

<div class="container">
    <h1>Parser Turni v2.9 - Full Line Mapping</h1>
    
    <div class="upload-section">
        <div class="box"><label>1. <b>rotazioni.txt</b></label><br><br><input type="file" id="rotTxt" accept=".txt"></div>
        <div class="box"><label>2. <b>PDF Turni</b></label><br><br><input type="file" id="pdfFile" accept="application/pdf"></div>
    </div>

    <div class="progress" id="pDiv"><div id="bar"></div></div>
    <button id="startBtn">Esegui Scansione Completa</button>
    <div id="log">Pronto per l'estrazione totale.</div>
</div>

<script>
    const pdfjsLib = window['pdfjs-dist/build/pdf'];
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

    function addLog(msg) {
        const l = document.getElementById('log');
        l.innerText += "\n> " + msg;
        l.scrollTop = l.scrollHeight;
    }

    function pulisciLuogo(t) {
        if(!t) return "";
        return t.replace(/MONTA|SMONTA|alle|DURATA|Servizio|Validità|Tipologia|INTERO|PICCOLE|UNITA'|Nota|Indennità|[\d]{1,2}\.[\d]{2}|[:.\-_]{2,}/gi, "")
                .replace(/\s+/g, ' ').trim();
    }

    // Mappa i prefissi delle rotazioni alle linee reali del PDF
    function matchLinee(codiceRotazione, lineaPDF) {
        const c = codiceRotazione.toUpperCase();
        const p = lineaPDF.toUpperCase();
        
        // Esempi: 4P -> 4.1 o 4.2 | 1C -> 1 | 2C -> 2 | M2 -> M2
        if (c.startsWith("4P") && (p === "4.1" || p === "4.2" || p === "4")) return true;
        if (c.startsWith("1C") && p === "1") return true;
        if (c.startsWith("2C") && p === "2") return true;
        if (c.startsWith("6P") && p === "6") return true;
        if (c.startsWith("CO") && p === "CO") return true;
        if (c.startsWith("M2") && p === "M2") return true;
        
        // Ritorno base se sono identici
        return c.replace(/[^A-Z0-9]/g, '') === p.replace(/[^A-Z0-9]/g, '');
    }

    function parseCodice(c) {
        c = c.toLowerCase().trim();
        if (c === "disp" || c.length < 2) return null;
        let match = c.match(/^([a-z0-9]+?)([0-9]+)$/i);
        if (match) {
            return { or: c.toUpperCase(), pref: match[1].toUpperCase(), num: parseInt(match[2], 10).toString() };
        }
        return null;
    }

    document.getElementById('startBtn').addEventListener('click', async () => {
        const rotFile = document.getElementById('rotTxt').files[0];
        const pdfFile = document.getElementById('pdfFile').files[0];
        if(!rotFile || !pdfFile) return alert("Carica entrambi i file");

        document.getElementById('pDiv').style.display = "block";
        const log = document.getElementById('log');
        log.innerText = "Caricamento codici...";

        const rotText = await rotFile.text();
        const codiciRaw = rotText.match(/([a-zA-Z0-9]+)/g) || [];
        const mappa = Array.from(new Set(codiciRaw.map(c => JSON.stringify(parseCodice(c))))).map(s => JSON.parse(s)).filter(x => x !== null);
        
        addLog("Ricerca avviata per " + mappa.length + " turni.");

        const arrayBuffer = await pdfFile.arrayBuffer();
        const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
        let dbTurni = {};

        for (let i = 1; i <= pdf.numPages; i++) {
            document.getElementById('bar').style.width = (i/pdf.numPages*100) + "%";
            const page = await pdf.getPage(i);
            const content = await page.getTextContent();
            const text = content.items.map(item => item.str).join(" ").replace(/\s+/g, " ");

            // Regex migliorata per catturare Linea e Turno (anche con caratteri speciali)
            const lM = text.match(/LINEA[:\s]+([A-Z0-9.]+)/i);
            const tM = text.match(/TURNO[:\s]+(\d+)/i);

            if (lM && tM) {
                const pdfL = lM[1].trim();
                const pdfT = parseInt(tM[1], 10).toString();
                
                const targets = mappa.filter(c => c.num === pdfT && matchLinee(c.pref, pdfL));

                if (targets.length > 0) {
                    const headerArea = text.split(/Nota servizio/i)[0];
                    const pairRegex = /([A-Z.\s']{3,})\s+(\d{1,2}\.\d{2})/g;
                    let matches = [];
                    let m;
                    while ((m = pairRegex.exec(headerArea)) !== null) {
                        matches.push({ luogo: pulisciLuogo(m[1]), ora: m[2] });
                    }

                    if (matches.length >= 2) {
                        const start = matches[0];
                        const end = matches[matches.length - 1];

                        targets.forEach(t => {
                            dbTurni[t.or] = {
                                inizio: start.ora.replace('.', ':'),
                                luogoInizio: start.luogo,
                                fine: end.ora.replace('.', ':'),
                                luogoFine: end.luogo
                            };
                            addLog("OK: " + t.or + " (Linea " + pdfL + " Turno " + pdfT + ")");
                        });
                    }
                }
            }
        }

        if (Object.keys(dbTurni).length > 0) {
            const blob = new Blob([JSON.stringify(dbTurni, null, 2)], { type: "application/json" });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = "database_completo_atvo.json";
            a.click();
            addLog("\nCOMPLETATO! " + Object.keys(dbTurni).length + " turni estratti.");
        } else {
            addLog("\nERRORE CRITICO: Nessun turno estratto. Controlla i log sopra.");
        }
    });
</script>
</body>
</html>
